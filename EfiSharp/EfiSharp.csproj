<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net5.0</TargetFramework>
    <LangVersion>9.0</LangVersion>
    <Platforms>x64;x86</Platforms>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\EfiSharp.Console\EfiSharp.Console.csproj" />
    <ProjectReference Include="..\EFISharp.CoreLib\EFISharp.CoreLib.csproj" />
  </ItemGroup>

  <PropertyGroup>
    <NoStdLib>true</NoStdLib>
    <NoConfig>true</NoConfig>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Optimize>true</Optimize>
    <IlcOptimizationPreference>Size</IlcOptimizationPreference>
    <IlcDisableReflection>true</IlcDisableReflection>
    <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
    <GenerateTargetFrameworkAttribute>false</GenerateTargetFrameworkAttribute>
    <DisableImplicitFrameworkReferences>true</DisableImplicitFrameworkReferences>
    <IlcSystemModule>EfiSharp.CoreLib</IlcSystemModule>
  </PropertyGroup>

  <PropertyGroup>
    <!---->
    <LinkerSubsystem>EFI_APPLICATION</LinkerSubsystem>
    <EntryPointSymbol>EfiMain</EntryPointSymbol>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.DotNet.ILCompiler" Version="6.0.0-*" />
    <!-- Ideally the linker would be disabled or modified to give the correct error output for the linker errors but I have no clue how to do that.
         This is relevent since when new managed code requires new interop functions like those in StartupCodeHelpers, dotnet publish using the
         ilcompiler will cause the linker to output ~50 errors unrelated to the missing interop function(s). Instead, directly calling the linker
         produces errors related to the missing functions. Example: https://i.imgur.com/Hl8AIoi.png everything in red is from dotnet publish 
         and the white lines are from a seperate manual link.exe call.
         At minimum, removing the entry argument prevents the dotnet publish linker call from functioning and cuts down the number of errors. 

         6/2/2021: It turns out that the first set of errors is due to Runtime.lib being included by the compiler, this is not normally a problem since all unused
         functions are stripped out by default. This holds for both the v1 and v6 compilers. In the event of unimplemented functions, the linker shows all examples
         before Runtime.lib issues are ignored. When running the linker manually with the getlinkererrors argument, the red errors are left over from when the runtime
         is not stripped out and adds in libcmt.lib and the second set of white errors tend to be the actual errors since in that linker call, these extra libaries
         are not included leaving only actual errors. -->
    <!--<LinkerArg Condition="'$(Mode)' != 'nolinker'" Include="/subsystem:EFI_APPLICATION /entry:EfiMain" />-->
    <LinkerArg Include="..\EfiSharp.Native\x64\release\EFiSharp.Native.lib" />
  </ItemGroup>
</Project>