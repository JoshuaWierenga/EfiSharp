<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net5.0</TargetFramework>
    <LangVersion>9.0</LangVersion>
    <Platforms>x64;x86</Platforms>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\EfiSharp.Console\EfiSharp.Console.csproj" />
    <ProjectReference Include="..\EFISharp.CoreLib\EFISharp.CoreLib.csproj" />
  </ItemGroup>

  <PropertyGroup>
    <NoStdLib>true</NoStdLib>
    <NoConfig>true</NoConfig>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Optimize>true</Optimize>
    <IlcOptimizationPreference>Size</IlcOptimizationPreference>
    <IlcDisableReflection>true</IlcDisableReflection>
    <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
    <GenerateTargetFrameworkAttribute>false</GenerateTargetFrameworkAttribute>
    <DisableImplicitFrameworkReferences>true</DisableImplicitFrameworkReferences>
    <IlcSystemModule>EfiSharp.CoreLib</IlcSystemModule>
  </PropertyGroup>

  <PropertyGroup>
    <!---->
    <LinkerSubsystem>EFI_APPLICATION</LinkerSubsystem>
    <EntryPointSymbol>EfiMain</EntryPointSymbol>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.DotNet.ILCompiler" Version="6.0.0-*" />
    <!-- Ideally the linker would be disabled or modified to give the correct error output for the linker errors but I have no clue how to do that.
         This is relevent since when new managed code requires new interop functions like those in StartupCodeHelpers, dotnet publish using the
         ilcompiler will cause the linker to output ~50 errors unrelated to the missing interop function(s). Instead, directly calling the linker
         produces errors related to the missing functions. Example: https://i.imgur.com/Hl8AIoi.png everything in red is from dotnet publish 
         and the white lines are from a seperate manual link.exe call.
         At minimum, removing the entry argument prevents the dotnet publish linker call from functioning and cuts down the number of errors. 

         6/2/2021: It turns out that the first set of errors is due to Runtime.lib being included by the compiler, this is not normally a problem since all unused
         functions are stripped out by default. This holds for both the v1 and v6 compilers. In the event of unimplemented functions, the linker shows all examples
         before Runtime.lib issues are ignored. When running the linker manually with the getlinkererrors argument, the red errors are left over from when the runtime
         is not stripped out and adds in libcmt.lib and the second set of white errors tend to be the actual errors since in that linker call, these extra libaries
         are not included leaving only actual errors. -->
    <!--<LinkerArg Condition="'$(Mode)' != 'nolinker'" Include="/subsystem:EFI_APPLICATION /entry:EfiMain" />-->
    <LinkerArg Include="..\EfiSharp.Native\x64\release\EFiSharp.Native.lib" />
  </ItemGroup>

  <Target Name="GenerateVirtualDisk" AfterTargets="Publish" Condition="'$(Mode)' != 'nolinker'">
    <PropertyGroup>
      <VHD>"$(MSBuildProjectDirectory)\$(NativeOutputPath)EfiSharp.vhd"</VHD>
      <CreatePartitionCommand>
        create vdisk file=$(VHD) maximum=40
        select vdisk file=$(VHD)
        attach vdisk
        convert gpt
        create partition efi
        format quick fs=fat32 label="System"
        assign letter="X"
        exit
      </CreatePartitionCommand>
      <CreatePartitionCommand2>
        select vdisk file=$(VHD)
        select partition 1
        remove letter=X
        detach vdisk
        exit
      </CreatePartitionCommand2>
    </PropertyGroup>

    <Exec Command="del $(VHD)" ContinueOnError="true" EchoOff="true" />

    <WriteLinesToFile File="$(NativeOutputPath)diskpart1.txt" Overwrite="true" Lines="$(CreatePartitionCommand)" />

    <WriteLinesToFile File="$(NativeOutputPath)diskpart2.txt" Overwrite="true" Lines="$(CreatePartitionCommand2)" />
    <Exec EchoOff="true" Command="diskpart /s &quot;$(MSBuildProjectDirectory)\$(NativeOutputPath)diskpart1.txt&quot;" />
    <Copy SourceFiles="$(MSBuildProjectDirectory)\$(NativeOutputPath)$(TargetName)$(NativeBinaryExt)" DestinationFiles="X:\EFI\BOOT\BOOTX64.efi" />
    <Exec EchoOff="true" Command="diskpart /s &quot;$(MSBuildProjectDirectory)\$(NativeOutputPath)diskpart2.txt&quot;" />

    <!-- https://ashwaniashwin.wordpress.com/2019/07/27/account-does-not-have-permission-to-open-the-attachment-hyper-v-vm-error/ -->
    <!-- Uuid will have to be changed for each different vm. -->
    <!-- This may not be required if the current user has full permissions for the project folder before vhd generation. -->
    <Exec EchoOff="true" Condition="'$(Mode)' == 'hyperv'" Command="icacls $(VHD) /grant b4f6dd43-1d78-4364-84d0-b4bae6422fdb:F" />

    <!-- https://forums.virtualbox.org/viewtopic.php?f=8&t=50639 -->
    <!-- Use "VBoxManage list hdds" to find the correct uuid after first manually adding the vhd to virtualbox and put it here.
         Unlike hyperv which boots directly into the image, virtualbox in efi mode boots into an efi console. 
         Use "exit" to get to into the menu, then go to "Boot Manager" followed by "UEFI VBOX HARDDISK *". -->
    <Exec EchoOff="true" Condition="'$(Mode)' == 'virtualbox'" Command="&quot;C:\Program Files\Oracle\VirtualBox\VBoxManage.exe&quot; internalcommands sethduuid $(VHD) 76d017a4-76d0-4cf3-aab3-eb97b0e70f2d" />
  </Target>

  <Target Name="FixPartialVirtualDisk">
    <PropertyGroup>
      <VHD>"$(MSBuildProjectDirectory)\$(NativeOutputPath)EfiSharp.vhd"</VHD>
      <CreatePartitionCommand2>
        select vdisk file=$(VHD)
        select partition 1
        remove letter=X
        detach vdisk
        exit
      </CreatePartitionCommand2>
    </PropertyGroup>

    <WriteLinesToFile File="$(NativeOutputPath)diskpart2.txt" Overwrite="true" Lines="$(CreatePartitionCommand2)" />
    <Exec EchoOff="true" Command="diskpart /s &quot;$(MSBuildProjectDirectory)\$(NativeOutputPath)diskpart2.txt&quot;" />
  </Target>
</Project>