<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net5.0</TargetFramework>
    <LangVersion>9.0</LangVersion>
    <Platforms>x64;x86</Platforms>
  </PropertyGroup>

  <PropertyGroup>
    <NoStdLib>true</NoStdLib>
    <NoConfig>true</NoConfig>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Optimize>true</Optimize>
    <IlcOptimizationPreference>Size</IlcOptimizationPreference>
    <IlcDisableReflection>true</IlcDisableReflection>
    <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
    <GenerateTargetFrameworkAttribute>false</GenerateTargetFrameworkAttribute>
    <DisableImplicitFrameworkReferences>true</DisableImplicitFrameworkReferences>
    <IlcSystemModule>EfiSharp.CoreLib</IlcSystemModule>
  </PropertyGroup>

  <ItemGroup>
    <!--- TODO Figure out how to fix linking issues with version 6.0.0-* is used, currently it fails and requires wmainCRTStartup. -->
    <PackageReference Include="Microsoft.DotNet.ILCompiler" Version="1.0.0-alpha-*" />
    <!-- Ideally the linker would be disabled or modifed to give the correct error output for the linker errors but I have no clue how to do that.
         This is relevent since when new managed code requires new interop functions like those in StartupCodeHelpers, dotnet publish using the
         ilcompiler will cause the linker to output ~50 errors unrelated to the missing interop function(s). Instead, directly calling the linker
         produces errors related to the missing functions. Example: https://i.imgur.com/Hl8AIoi.png everything in red is from dotnet publish 
         and the white lines are from a seperate manual link.exe call.
         At minimum, removing the entry argument prevents the dotnet publish linker call from functioning and cuts down the number of errors. -->
    <LinkerArg Condition="'$(Mode)' != 'nolinker'" Include="/subsystem:EFI_APPLICATION /entry:EfiMain" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\..\EfiSharp.Console\EfiSharp.Console.csproj" />
    <ProjectReference Include="..\..\..\..\EfiSharp.CoreLib\EfiSharp.CoreLib.csproj" />
  </ItemGroup>

  <Target Name="GenerateVirtualDisk" AfterTargets="Publish">
    <PropertyGroup>
      <VHD>"$(MSBuildProjectDirectory)\$(NativeOutputPath)EfiSharp.vhd"</VHD>
      <CreatePartitionCommand>
        create vdisk file=$(VHD) maximum=40
        select vdisk file=$(VHD)
        attach vdisk
        convert gpt
        create partition efi
        format quick fs=fat32 label="System"
        assign letter="X"
        exit
      </CreatePartitionCommand>
      <CreatePartitionCommand2>
        select vdisk file=$(VHD)
        select partition 1
        remove letter=X
        detach vdisk
        exit
      </CreatePartitionCommand2>
    </PropertyGroup>

    <Exec Command="del $(VHD)" />

    <WriteLinesToFile File="$(NativeOutputPath)diskpart1.txt" Overwrite="true" Lines="$(CreatePartitionCommand)" />

    <WriteLinesToFile File="$(NativeOutputPath)diskpart2.txt" Overwrite="true" Lines="$(CreatePartitionCommand2)" />
    <Exec Command="diskpart /s &quot;$(MSBuildProjectDirectory)\$(NativeOutputPath)diskpart1.txt&quot;" />
    <Copy SourceFiles="$(MSBuildProjectDirectory)\$(NativeOutputPath)$(TargetName)$(NativeBinaryExt)" DestinationFiles="X:\EFI\BOOT\BOOTX64.efi" />
    <Exec Command="diskpart /s &quot;$(MSBuildProjectDirectory)\$(NativeOutputPath)diskpart2.txt&quot;" />

    <!-- https://ashwaniashwin.wordpress.com/2019/07/27/account-does-not-have-permission-to-open-the-attachment-hyper-v-vm-error/ -->
    <!-- Uuid will have to be changed for each different vm. -->
    <Exec Condition="'$(Mode)' == 'hyperv'" Command="icacls $(VHD) /grant 21b4575f-9342-4f2b-8a75-b5bd74986c19:F" />

    <!-- https://forums.virtualbox.org/viewtopic.php?f=8&t=50639 -->
    <!-- Use "VBoxManage list hdds" to find the correct uuid after first manually adding the vhd to virtualbox and put it here.
         Unlike hyperv which boots directly into the image, virtualbox in efi mode boots into an efi console. 
         Use "exit" to get to into the menu, then go to "Boot Manager" followed by "UEFI VBOX HARDDISK *". -->
    <Exec Condition="'$(Mode)' == 'virtualbox'" Command="&quot;C:\Program Files\Oracle\VirtualBox\VBoxManage.exe&quot; internalcommands sethduuid $(VHD) f003e87a-5a7b-400b-a432-d87374679986" />
  </Target>
</Project>
